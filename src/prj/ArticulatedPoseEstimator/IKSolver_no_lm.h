	double Solve(int frame_index,Array<int> *VertexIndex,Vector<3> *Targets,int Num_of_Iteration=1,double Stop_Error_Th=0,double Max_Allowed_Rotation_Angle=40);
	double Perspective_Solve(int frame_index,Array<TargetListItem_type> *TargetList,int Num_of_Iteration=1,double Stop_Error_Th=0,double Max_Allowed_Rotation_Angle=40);
	double Perspective_Solve_Limits(int frame_index,Array<TargetListItem_type> *TargetList,int Num_of_Iteration=1,double Stop_Error_Th=0,double Max_Allowed_Rotation_Angle=40,Array<int> *Limited_=NULL,Array<double> *Limits_=NULL);
	// 
	//
	// -1    I didn't do anything 
	// !=-1  Errore sui target (quello esatto non quello linearizzato)
	// Max_Allowed_Rotation_Angle:          Controllo correttezza linearizzazione (gradi massimi di rotatione per passo)
	//                                      0  ->  Elimina il controllo 
	// Stop_Error_Th:                       Si ferma dopo Num_of_Iteration oppure se errore<=Stop_Error_Th



double IKSolver::Solve(int frame_index,Array<int> *VertexIndex,Vector<3> *Targets,int Num_of_Iteration,double Stop_Error_Th,double Max_Allowed_Rotation_Angle) {
	double Tot_Err=-1;
	double Old_Tot_Err=-1;
	Vector<3> tmp_p;
	Vector<4> e,point;
	Matrix B(3*VertexIndex->numElements(),1);
	Matrix X(3*VertexIndex->numElements(),num_Freedom_Degrees);
	Matrix I(num_Freedom_Degrees,3*VertexIndex->numElements());
	Matrix Delta(num_Freedom_Degrees,1);


	
	for(int iteration=0;iteration<Num_of_Iteration;iteration++) {
		Computa_D_AM(frame_index);

		for(int i=0;i<VertexIndex->numElements();i++) {
			// Get Point
			int point_index=(*VertexIndex)[i];
			tmp_p=mesh->Points[point_index];
			point[0]=tmp_p[0];
			point[1]=tmp_p[1];
			point[2]=tmp_p[2];
			point[3]=1.0;

			// Set Traslazione obbiettivo
			B[i*3][0]=Targets[point_index][0]-point[0];
			B[i*3+1][0]=Targets[point_index][1]-point[1];
			B[i*3+2][0]=Targets[point_index][2]-point[2];

			
			// Resetto la colonna X[i*3][:]
			for(int j=0;j<num_Freedom_Degrees;j++) {
				X[i*3][j]=0.0;
				X[i*3+1][j]=0.0;
				X[i*3+2][j]=0.0;
			}
			
			// Calcolo variazione di point (colonna X[i*3][:])
			for(int bone_=0;bone_<mesh->num_bones;bone_++) {
				double w_tmp=mesh->Weigth[point_index][bone_];
				if (w_tmp!=0.0) {
					
					for(int j=0;j<num_Freedom_Degrees;j++) {
						Matrix *D_AM_tmp=D_AM[(bone_*num_Freedom_Degrees)+j];

						if (Freedom_Degrees[j].type<3) {
							Multiply(D_AM_tmp,point,e.GetList());
						} else {
							e[0]=(*D_AM_tmp)[0][3];
							e[1]=(*D_AM_tmp)[1][3];
							e[2]=(*D_AM_tmp)[2][3];
						}

						X[i*3][j]+=w_tmp*e[0];
						X[i*3+1][j]+=w_tmp*e[1];	
						X[i*3+2][j]+=w_tmp*e[2];
					}

				}
			}


			// Passa alla riga di X successiva 
		}

		



		// Risolve il problema 
		int SolveResult=SolveAXB(&X,&B,&Delta,&I);
		if (SolveResult&SOLVE_ERROR_UNDERDETERMINATED) return -1;




		// Controlla se Delta appartiene ad un intorno di 0
		double R_Correction=1.0;
		if (Max_Allowed_Rotation_Angle!=0) {
			double maxR=0.0;
			double Max_Rotation=Max_Allowed_Rotation_Angle*3.1415/180.0;
			for(int k=0;k<num_Freedom_Degrees;k++) {
				Bone *Curr=Freedom_Degrees[k].Ref;
				int type=Freedom_Degrees[k].type;

				if (type<3) {
					Vector<3> s;
					s[type]=Delta[k][0];
					while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type<3)) {
						k++;
						s[Freedom_Degrees[k].type]=Delta[k][0];
					}
					cout<<Curr->GetName()<<" ruota di "<<(s.Norm2()*180.0/3.1415)<<"\n";
					if (s.Norm2()>maxR) maxR=s.Norm2();
				} else {
					Vector<3> s;
					s[type-3]=Delta[k][0];
					while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type>=3)) {
						k++;
						s[Freedom_Degrees[k].type-3]=Delta[k][0];
					}
					cout<<Curr->GetName()<<" trasla di "<<s.Norm2()<<"\n";
				}
			}
			
			if (maxR>Max_Rotation) {
				R_Correction=Max_Rotation/maxR;
				cout<<"Correzione R = "<<R_Correction<<"\n";
			}
		}
		

		// Aggiorna Stato
		for(int k=0;k<num_Freedom_Degrees;k++) {
			Bone *Curr=Freedom_Degrees[k].Ref;
			int type=Freedom_Degrees[k].type;
			
			if (type<3) {
				Vector<3> s;
				s[type]=Delta[k][0];
				while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type<3)) {
					k++;
					s[Freedom_Degrees[k].type]=Delta[k][0];
				}
				s=s*R_Correction;

				
				// TODO
				Matrix R(3,3);
				Matrix Tot(3,3);							// TODO: Inserire il controllo vincoli 
				AngleAxis2RotationMatrix(&R,s); 			/* TODO: Speriamo di nn aver mai assunto che M = eX*eY*eZ altrimenti l'ordine cambia tutto... */
				Multiply(&R,Curr->RelativeTrasformationMatrix[frame_index],&Tot);
				
			/*	if (!Curr->is("Bone_Bip01 Head")) 
					if (!Curr->is("Bone_Bip01 L Clavicle")) 
						if (!Curr->is("Bone_Bip01 R Clavicle")) 
							if (!Curr->is("Bone_Bip01 Neck")) */
								Curr->RelativeTrasformationMatrix[frame_index]->Set(&Tot);

			} else {
				Vector<3> s;
				s[type-3]=Delta[k][0];
				while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type>=3)) {
					k++;
					s[Freedom_Degrees[k].type-3]=Delta[k][0];
				}
				Curr->RelativeTrasformationT[frame_index]+=s;
			}
		}
		
		
		// Aggiorna struttura
		mesh->BoneRoot->CalcAbsoluteFromRelative(frame_index);
		mesh->Apply_Skin(frame_index);

		
		// Calcola errore
		Tot_Err=0;
		Vector<3> err_tmp;
		for(int i=0;i<VertexIndex->numElements();i++) {
			err_tmp=(Targets[(*VertexIndex)[i]]-mesh->Points[(*VertexIndex)[i]]);
			double tmp=err_tmp.Norm2();
			Tot_Err+=tmp*tmp;
		}
		cout<<"Iterazione n."<<iteration<<":   Errore totale = "<<Tot_Err;
		if (Old_Tot_Err==-1) Old_Tot_Err=Tot_Err;
		else {
			if (Old_Tot_Err>=Tot_Err) cout<<" (Decreasing)";
			else cout<<" (Increasing)";
			Old_Tot_Err=Tot_Err;
		}
		cout<<"\n";
		// NB: Tot_Err potrebbe salire e scendere vicino al punto di equilibrio, se qlcuno vuole mettere un controllo puo' farlo
		//     ma non ci guadagnerebbe tanto infatti la salita potrebbe essere giustificata da una uscita da un minimo locale.

		// Considerazioni su errore
		if (Tot_Err<=Stop_Error_Th) break;
	}

	// Aggiorna normali
	mesh->ComputaNormals();	
	return Tot_Err;
}













/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






double IKSolver::Perspective_Solve(int frame_index,Array<TargetListItem_type> *TargetList,int Num_of_Iteration,double Stop_Error_Th,double Max_Allowed_Rotation_Angle) {
	double Tot_Err=-1;
	double Old_Tot_Err=-1;
	Vector<2> Initial_Position;
	Vector<3> PP;
	Vector<3> tmp_p;
	Vector<4> tmp_row_m;
	Vector<3> dPPt;
	Vector<4> e,point;
	Matrix B(2*TargetList->numElements(),1);						// TODO: globali
	Matrix X(2*TargetList->numElements(),num_Freedom_Degrees);
	Matrix I(num_Freedom_Degrees,2*TargetList->numElements());
	Matrix Delta(num_Freedom_Degrees,1);
	int Zero_Anomalies=0;

	for(int iteration=0;iteration<Num_of_Iteration;iteration++) {
		Computa_D_AM(frame_index);

		for(int i=0;i<TargetList->numElements();i++) {
			// Get Point
			int point_index=(*TargetList)[i].VertexIndex;
			tmp_p=mesh->Points[point_index];
			double Target_Weight=mesh->AreaPoint[point_index];
			point[0]=tmp_p[0];
			point[1]=tmp_p[1];
			point[2]=tmp_p[2];
			point[3]=1.0;
			
			PP=(*TargetList)[i].View->Trasform(tmp_p);			        // TODO Occhio doppia 
			Initial_Position=(*TargetList)[i].View->Projection(tmp_p);  // TODO Occhio doppia 


			// Set Traslazione obbiettivo
			B[i*2][0]=Target_Weight*((*TargetList)[i].Target[0]-Initial_Position[0]);
			B[i*2+1][0]=Target_Weight*((*TargetList)[i].Target[1]-Initial_Position[1]);


			
			// Resetto le colonne ROW[:]
			for(int j=0;j<num_Freedom_Degrees;j++) ROW[j].SetZero();
			
			// Calcolo variazione dP 3D di point
			for(int bone_=0;bone_<mesh->num_bones;bone_++) {
				double w_tmp=mesh->Weigth[point_index][bone_];
				if (w_tmp!=0.0) {
					
					for(int j=0;j<num_Freedom_Degrees;j++) {
						Matrix *D_AM_tmp=D_AM[(bone_*num_Freedom_Degrees)+j];

						if (Freedom_Degrees[j].type<3) {
							Multiply(D_AM_tmp,point,e.GetList());
						} else {
							e[0]=(*D_AM_tmp)[0][3];
							e[1]=(*D_AM_tmp)[1][3];
							e[2]=(*D_AM_tmp)[2][3];
						}

						ROW[j][0]+=w_tmp*e[0];
						ROW[j][1]+=w_tmp*e[1];
						ROW[j][2]+=w_tmp*e[2];
					}

				}
			}

			for(int j=0;j<num_Freedom_Degrees;j++) {
				// Compute R*dP -> dPPt
				tmp_row_m[0]=ROW[j][0];
				tmp_row_m[1]=ROW[j][1];
				tmp_row_m[2]=ROW[j][2];
				tmp_row_m[3]=0.0;
				
				if (!IS_ZERO(tmp_row_m.Norm2(),DBL_EPSILON)) {
					Multiply(&((*TargetList)[i].View->P),tmp_row_m,dPPt.GetList());
					double factor=1.0/(PP[2]*PP[2]);
					if (dPPt[2]==0) Zero_Anomalies++;
					X[i*2][j]=Target_Weight*factor*(PP[2]*dPPt[0]-PP[0]*dPPt[2]);
					X[i*2+1][j]=Target_Weight*factor*(PP[2]*dPPt[1]-PP[1]*dPPt[2]);
				} else {
					X[i*2][j]=0.0;
					X[i*2+1][j]=0.0;
				}
			}



			// Passa alla riga di X successiva 
		}

		


		
		// Risolve il problema 
		int SolveResult=SolveAXB(&X,&B,&Delta,&I);
		if (SolveResult&SOLVE_ERROR_UNDERDETERMINATED) {
			delete ROW;
			return -1;
		}


		// Controlla se Delta appartiene ad un intorno di 0
		double R_Correction=1.0;
		if (Max_Allowed_Rotation_Angle!=0) {
			double maxR=0.0;
			double Max_Rotation=Max_Allowed_Rotation_Angle*3.1415/180.0;
			for(int k=0;k<num_Freedom_Degrees;k++) {
				Bone *Curr=Freedom_Degrees[k].Ref;
				int type=Freedom_Degrees[k].type;

				if (type<3) {
					Vector<3> s;
					s[type]=Delta[k][0];
					while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type<3)) {
						k++;
						s[Freedom_Degrees[k].type]=Delta[k][0];
					}
					cout<<Curr->GetName()<<" ruota di "<<(s.Norm2()*180.0/3.1415)<<"\n";
					if (s.Norm2()>maxR) maxR=s.Norm2();
				} else {
					Vector<3> s;
					s[type-3]=Delta[k][0];
					while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type>=3)) {
						k++;
						s[Freedom_Degrees[k].type-3]=Delta[k][0];
					}
					cout<<Curr->GetName()<<" trasla di "<<s.Norm2()<<"\n";
				}
			}
			
			if (maxR>Max_Rotation) {
				R_Correction=Max_Rotation/maxR;
				cout<<"Correzione R = "<<R_Correction<<"\n";
			}
		}
		
		// Aggiorna Stato
		Vector<3> EffectiveRotation;
		for(int k=0;k<num_Freedom_Degrees;k++) {
			Bone *Curr=Freedom_Degrees[k].Ref;
			int type=Freedom_Degrees[k].type;
			
			if (type<3) {
				Vector<3> s;
				s[type]=Delta[k][0];
				while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type<3)) {
					k++;
					s[Freedom_Degrees[k].type]=Delta[k][0];
				}
				s=s*R_Correction;

				Curr->Rotate(frame_index,s,EffectiveRotation);
			} else {
				Vector<3> s;
				s[type-3]=Delta[k][0];
				while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type>=3)) {
					k++;
					s[Freedom_Degrees[k].type-3]=Delta[k][0];
				}
				Curr->RelativeTrasformationT[frame_index]+=s;
			}
		}
		

		// Aggiorna struttura
		mesh->BoneRoot->CalcAbsoluteFromRelative(frame_index);
		mesh->Apply_Skin(frame_index);

		

		// Calcola errore
		Tot_Err=0;
		Vector<2> err_tmp;
		for(int i=0;i<TargetList->numElements();i++) {
			int point_index=(*TargetList)[i].VertexIndex;
			tmp_p=mesh->Points[point_index];
			err_tmp=(*TargetList)[i].Target-((*TargetList)[i].View->Projection(tmp_p));

			double tmp=err_tmp.Norm2();
			Tot_Err+=tmp*tmp;
		}
		cout<<"Iterazione n."<<iteration<<":   Errore totale = "<<Tot_Err;
		if (Old_Tot_Err==-1) Old_Tot_Err=Tot_Err;
		else {
			if (Old_Tot_Err>=Tot_Err) cout<<" (Decreasing)";
			else cout<<" (Increasing)";
			Old_Tot_Err=Tot_Err;
		}
		cout<<"\n";
		// NB: Tot_Err potrebbe salire e scendere vicino al punto di equilibrio, se qlcuno vuole mettere un controllo puo' farlo
		//     ma non ci guadagnerebbe tanto infatti la salita potrebbe essere giustificata da una uscita da un minimo locale.

		// Considerazioni su errore
		if (Tot_Err<=Stop_Error_Th) break;
	}

	cout<<"\nZero anomalies "<<Zero_Anomalies<<"\n";
	// Aggiorna normali
	mesh->ComputaNormals();	


	return Tot_Err;
}











/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



double IKSolver::Perspective_Solve_Limits(int frame_index,Array<TargetListItem_type> *TargetList,int Num_of_Iteration,double Stop_Error_Th,double Max_Allowed_Rotation_Angle,Array<int> *Limited_,Array<double> *Limits_) {
	double Tot_Err=-1;
	double Old_Tot_Err=-1;
	Vector<2> Initial_Position;
	Vector<3> PP;
	Vector<3> tmp_p;
	Vector<4> tmp_row_m;
	Vector<3> dPPt;
	Vector<4> e,point;
	Matrix B(2*TargetList->numElements()+num_Freedom_Degrees,1);						// TODO: globali
	Matrix X(2*TargetList->numElements()+num_Freedom_Degrees,num_Freedom_Degrees);
	Matrix I(num_Freedom_Degrees,2*TargetList->numElements()+num_Freedom_Degrees);
	Matrix Delta(num_Freedom_Degrees,1);


	for(int iteration=0;iteration<Num_of_Iteration;iteration++) {
		Computa_D_AM(frame_index);

		for(int i=0;i<TargetList->numElements();i++) {
			// Get Point
			int point_index=(*TargetList)[i].VertexIndex;
			tmp_p=mesh->Points[point_index];
			double Target_Weight=mesh->AreaPoint[point_index];
			point[0]=tmp_p[0];
			point[1]=tmp_p[1];
			point[2]=tmp_p[2];
			point[3]=1.0;
			
			PP=(*TargetList)[i].View->Trasform(tmp_p);			        // TODO Occhio doppia 
			Initial_Position=(*TargetList)[i].View->Projection(tmp_p);  // TODO Occhio doppia 


			// Set Traslazione obbiettivo
			B[i*2][0]=Target_Weight*((*TargetList)[i].Target[0]-Initial_Position[0]);
			B[i*2+1][0]=Target_Weight*((*TargetList)[i].Target[1]-Initial_Position[1]);


			
			// Resetto le colonne ROW[:]
			for(int j=0;j<num_Freedom_Degrees;j++) ROW[j].SetZero();
			
			// Calcolo variazione dP 3D di point
			for(int bone_=0;bone_<mesh->num_bones;bone_++) {
				double w_tmp=mesh->Weigth[point_index][bone_];
				if (w_tmp!=0.0) {
					
					for(int j=0;j<num_Freedom_Degrees;j++) {
						Matrix *D_AM_tmp=D_AM[(bone_*num_Freedom_Degrees)+j];

						if (Freedom_Degrees[j].type<3) {
							Multiply(D_AM_tmp,point,e.GetList());
						} else {
							e[0]=(*D_AM_tmp)[0][3];
							e[1]=(*D_AM_tmp)[1][3];
							e[2]=(*D_AM_tmp)[2][3];
						}

						ROW[j][0]+=w_tmp*e[0];
						ROW[j][1]+=w_tmp*e[1];
						ROW[j][2]+=w_tmp*e[2];
					}

				}
			}

			for(int j=0;j<num_Freedom_Degrees;j++) {
				// Compute R*dP -> dPPt
				tmp_row_m[0]=ROW[j][0];
				tmp_row_m[1]=ROW[j][1];
				tmp_row_m[2]=ROW[j][2];
				tmp_row_m[3]=0.0;
				
				if (!IS_ZERO(tmp_row_m.Norm2(),DBL_EPSILON)) {
					Multiply(&((*TargetList)[i].View->P),tmp_row_m,dPPt.GetList());
					double factor=1.0/(PP[2]*PP[2]);
					if (dPPt[2]==0) {
						cout<<"cavolo";
					}
					X[i*2][j]=Target_Weight*factor*(PP[2]*dPPt[0]-PP[0]*dPPt[2]);
					X[i*2+1][j]=Target_Weight*factor*(PP[2]*dPPt[1]-PP[1]*dPPt[2]);
				} else {
					X[i*2][j]=0.0;
					X[i*2+1][j]=0.0;
				}
			}



			// Passa alla riga di X successiva 
		}


		// Set Contraints
		for(int i=0;i<num_Freedom_Degrees;i++) {
			B[TargetList->numElements()*2+i][0]=0.0;
			for(int j=0;j<num_Freedom_Degrees;j++) 
				X[TargetList->numElements()*2+i][j]=0.0;
		}
		if (Limited_!=NULL) {
			cout<<"---------- WE ARE SETTING THE LIMITS ------------\n";
			
			#define ALPHA_LIMIT 5.0	// TODO

			for(int i=0;i<Limited_->numElements();i++) {
				X[TargetList->numElements()*2+(*Limited_)[i]][(*Limited_)[i]]=ALPHA_LIMIT*1.0;
				B[TargetList->numElements()*2+(*Limited_)[i]][0]=ALPHA_LIMIT*(*Limits_)[i];
			}
		}

		
		// Risolve il problema 
		int SolveResult=SolveAXB(&X,&B,&Delta,&I);
		if (SolveResult&SOLVE_ERROR_UNDERDETERMINATED) {
			delete ROW;
			return -1;
		}


		// Controlla se Delta appartiene ad un intorno di 0
		double R_Correction=1.0;
		if (Max_Allowed_Rotation_Angle!=0) {
			double maxR=0.0;
			double Max_Rotation=Max_Allowed_Rotation_Angle*3.1415/180.0;
			for(int k=0;k<num_Freedom_Degrees;k++) {
				Bone *Curr=Freedom_Degrees[k].Ref;
				int type=Freedom_Degrees[k].type;

				if (type<3) {
					Vector<3> s;
					s[type]=Delta[k][0];
					while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type<3)) {
						k++;
						s[Freedom_Degrees[k].type]=Delta[k][0];
					}
					cout<<Curr->GetName()<<" ruota di "<<(s.Norm2()*180.0/3.1415)<<"\n";
					if (s.Norm2()>maxR) maxR=s.Norm2();
				} else {
					Vector<3> s;
					s[type-3]=Delta[k][0];
					while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type>=3)) {
						k++;
						s[Freedom_Degrees[k].type-3]=Delta[k][0];
					}
					cout<<Curr->GetName()<<" trasla di "<<s.Norm2()<<"\n";
				}
			}
			
			if (maxR>Max_Rotation) {
				R_Correction=Max_Rotation/maxR;
				cout<<"Correzione R = "<<R_Correction<<"\n";
			}
		}
		
		// Aggiorna Stato
		Array<int> Limited(10);
		Array<double> Limits(10);
		Vector<3> EffectiveRotation;
		for(int k=0;k<num_Freedom_Degrees;k++) {
			Bone *Curr=Freedom_Degrees[k].Ref;
			int type=Freedom_Degrees[k].type;
			
			if (type<3) {
				Vector<3> s;
				s[type]=Delta[k][0];
				while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type<3)) {
					k++;
					s[Freedom_Degrees[k].type]=Delta[k][0];
				}
				s=s*R_Correction;

				if (Curr->Rotate(frame_index,s,EffectiveRotation)) {
					for(int i=0;i<3;i++) {
						if (!IS_ZERO(s[i],10e-4)) {
							if (!IS_ZERO(EffectiveRotation[i]-s[i],4*3.14/180)) {
								int h=k;
								if ((h>=0) && (Freedom_Degrees[h].type==i) && (Freedom_Degrees[h].Ref==Curr)) {
									if (!((Limited_) && (Limited_->search(h)!=-1))) {
										Limited.append(h);
										Limits.append(EffectiveRotation[i]);
										cout<<Freedom_Degrees[h].Ref->GetName()<<" is LIMITATED.\n";
									}
								}
								h--;
								if ((h>=0) && (Freedom_Degrees[h].type==i) && (Freedom_Degrees[h].Ref==Curr)) {
									if (!((Limited_) && (Limited_->search(h)!=-1))) {
										Limited.append(h);
										Limits.append(EffectiveRotation[i]);
										cout<<Freedom_Degrees[h].Ref->GetName()<<" is LIMITATED.\n";
									}
								}
								h--;
								if ((h>=0) && (Freedom_Degrees[h].type==i) && (Freedom_Degrees[h].Ref==Curr)) {
									if (!((Limited_) && (Limited_->search(h)!=-1))) {
										Limited.append(h);
										Limits.append(EffectiveRotation[i]);
										cout<<Freedom_Degrees[h].Ref->GetName()<<" is LIMITATED.\n";
									}
								}
							}
						}
					}
					
				}
			} else {
				Vector<3> s;
				s[type-3]=Delta[k][0];
				while ((k+1<num_Freedom_Degrees) && (Freedom_Degrees[k+1].Ref==Curr) && (Freedom_Degrees[k+1].type>=3)) {
					k++;
					s[Freedom_Degrees[k].type-3]=Delta[k][0];
				}
				Curr->RelativeTrasformationT[frame_index]+=s;
			}
		}
		
		if (Limited.numElements()!=0) {
			return Perspective_Solve_Limits(frame_index,TargetList,Num_of_Iteration,Stop_Error_Th,Max_Allowed_Rotation_Angle,&Limited,&Limits);
		}

		// Aggiorna struttura
		mesh->BoneRoot->CalcAbsoluteFromRelative(frame_index);
		mesh->Apply_Skin(frame_index);

		

		// Calcola errore
		Tot_Err=0;
		Vector<2> err_tmp;
		for(int i=0;i<TargetList->numElements();i++) {
			int point_index=(*TargetList)[i].VertexIndex;
			tmp_p=mesh->Points[point_index];
			err_tmp=(*TargetList)[i].Target-((*TargetList)[i].View->Projection(tmp_p));

			double tmp=err_tmp.Norm2();
			Tot_Err+=tmp*tmp;
		}
		cout<<"Iterazione n."<<iteration<<":   Errore totale = "<<Tot_Err;
		if (Old_Tot_Err==-1) Old_Tot_Err=Tot_Err;
		else {
			if (Old_Tot_Err>=Tot_Err) cout<<" (Decreasing)";
			else cout<<" (Increasing)";
			Old_Tot_Err=Tot_Err;
		}
		cout<<"\n";
		// NB: Tot_Err potrebbe salire e scendere vicino al punto di equilibrio, se qlcuno vuole mettere un controllo puo' farlo
		//     ma non ci guadagnerebbe tanto infatti la salita potrebbe essere giustificata da una uscita da un minimo locale.

		// Considerazioni su errore
		if (Tot_Err<=Stop_Error_Th) break;
	}

	// Aggiorna normali
	mesh->ComputaNormals();	


	return Tot_Err;
}





















/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
